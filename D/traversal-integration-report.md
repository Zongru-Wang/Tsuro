The implementation of our server specification that we received successfully implements most of what we specified.  Most of the implementor’s deviation from our specification added functionality we didn’t specify, so that the effort required to integrate our client module with their server implementation is minimal.  We assumed certain aspects of our specification were implied by the language we used to describe these features, so if we were to rewrite our specification, we would need make fewer assumptions and be clearer about what decisions the implementor is free to make on their own.

At the top of the spec we put in bold “If any function took in empty String as argument, then throw IllegalArgumentException”.  This is the only specified behavior that is not included in their implementation.  The exclusion of this behavior in the implementation can be added with minimal effort.  We could have made this point clearer by writing this constraint for every function that takes a string instead of including it at the top of our specification.  We also incorrectly assumed that our inclusion of the method addColoredToken implied that a node could have multiple tokens.  The implementors did not make the same assumption and added the restriction that each node was assigned at most one color.  We should have explicitly stated our intended relationship between colors and nodes under our description of addColoredToken.  Otherwise, the implementors correctly documented and implemented the behavior we specified for ILabyrinth.

The implementors added a number of private helper methods to assist in their implementation.  Most of these methods make the code very readable and we commend the implementors for their clarity.  The tokenExists method is the only method whose behavior wasn’t totally clear, but upon initial inspection it appears the method behaves in a way that allows the rest of the implementation to behave correctly.

The implementors also added public methods that extended the behavior of our specification.  This was not expected, and we should have been clearer about restricting ILabyrinth’s public interface.  One of the methods they included, moveToken, behaves in a way unspecified in our specification and outside of our understanding of the assignment.  Their moveToken method copies a colored token to a neighboring node.  They also included the method addNodeAnyway, which behaves exactly as addNode behaves but doesn’t throw an IllegalArgumentException if the given String is the name of an existing node in the labyrinth.  This effect could have been achieved by writing an external helper method which caught the IllegalArgumentException from addNode.  Again, asserting the exclusion of additional public methods within the ILabyrinth interface would have avoided this.

Along with the implementors addition of public and private methods within ILabyrinth, they added token and node classes.  We intended for them to do this but didn’t say they had the freedom to within our specification.  Another group of implementors may not have done this, so we should have specified it.  The relationship between their token and node class isn’t clear and seems overly complicated upon initial inspection, but everything we specified still seems to work correctly so this is a non-issue.

Overall the implementors did a good job of supporting everything we asked them to support aside from a few trivial exceptions.  Their inclusion of the public method moveToken is their most egregious addition assuming they misunderstood the assignment but is our most egregious omission if we misunderstood the assignment.  They also unnecessarily included an implementation of a simple client at the top of their code, but this wasn’t an issue since they also included a correct implementation of ILabyrinth.
